require 'tempfile'

class Resolver
  RESOLVER_DIR = Pathname("/etc/resolver")

  attr_reader :ip, :resolver_file, :amazeeio_cachalot_domain

  def initialize(ip, amazeeio_cachalot_domain = "docker.amazee.io")
    @ip = ip
    self.amazeeio_cachalot_domain = amazeeio_cachalot_domain
  end

  def amazeeio_cachalot_domain=(amazeeio_cachalot_domain)
    @amazeeio_cachalot_domain = amazeeio_cachalot_domain
    @resolver_file = RESOLVER_DIR.join(@amazeeio_cachalot_domain)
  end

  def up
    unless resolver_configured?
      configure_resolver!
    end
  end

  def name
    "DNS"
  end

  def clean?
    puts "Removing resolver file, this may require sudo"
    self.system!("removing resolverfile", "sudo", "rm", "-f", @resolver_file)
    system!("restarting mDNSResponder", "sudo", "killall", "mDNSResponder")
  end

  def configure_resolver!
    puts "setting up DNS resolution, this will require sudo"
    unless RESOLVER_DIR.directory?
      system!("creating #{RESOLVER_DIR}", "sudo", "mkdir", "-p", RESOLVER_DIR)
    end
    Tempfile.open('amazeeio_cachalot-dnsmasq') do |f|
      f.write(resolver_contents)
      f.close
      system!("creating #{@resolver_file}", "sudo", "cp", f.path, @resolver_file)
      system!("creating #{@resolver_file}", "sudo", "chmod", "644", @resolver_file)
    end
    system!("restarting mDNSResponder", "sudo", "killall", "mDNSResponder")
  end

  def resolver_configured?
    @resolver_file.exist? && File.read(@resolver_file) == resolver_contents
  end

  def system!(step, *args)
    system(*args.map(&:to_s)) || raise("Error with the #{name} daemon during #{step}")
  end

  def resolver_contents; <<-EOS.gsub(/^    /, '')
    # Generated by amazeeio_cachalot
    nameserver #{ip}
    port 53
    EOS
  end
end
